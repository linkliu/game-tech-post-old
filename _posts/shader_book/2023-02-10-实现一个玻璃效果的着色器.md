---
category: shader
tags: [U3D, Shader,Cookbook,中文版]
---

## 实现一个玻璃效果的着色器   
玻璃是一个非常复杂的材质；没必要对它刚到惊讶，在第四章，***向PBR中添加透明度*** 这个知识点中，***通过行为驱动开发创建测试用例和编写场景（Creating Test Cases and Writing Scenarios for Behavior Driven Development in Symfony）*** 我们已经创建了一个这样的着色器来模拟它了。然而，透明度没有办法复现玻璃的扭曲效果。大部分的玻璃自身是不完美的，所以当我们再看玻璃的时候会有扭曲效果。这个知识点我们将教你如何实现这样的效果。这个效果背后的思路是使用顶点和片元着色器以及抓取通道，然后对抓取纹理做一些修改并应用到它的UV数据中，从而实现扭曲效果。你可以从下面的图中看到效果，使用的是Unity标准资源库 **（Unity Standard Assets）** 中的玻璃染色纹理：   
![diagram](https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram70.png){:  .shadow width = "90%" }   

***   
<br>


- **始前准备**   
  这个知识点的步骤跟前一章中的有点像：
  1. 创建一个新的顶点和片元着色器。你可以复制前一个知识点 ***抓取通道*** 的着色器作为基础。
  2. 创建一个材质，用来承载着色器。
  3. 将材质球赋值给一个 **quad**，也可以是其他的扁平的几何图形，用来模拟玻璃。
  4. 然后再这个模拟的玻璃后面放一些其他的游戏物体，好观察扭曲效果。   

*** 
<br>

- **操作步骤【原书有错，下面是纠正后的步骤和代码】**   
  我们开始编辑顶点和片元着色器：   
  1. 向着色器的属性快 **（ Properties block）** 中添加4个属性：   
  ``` c#
  Properties
  {
    _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    _Colour("Colour", Color) = (1,1,1,1)
    _BumpMap("Noise text", 2D) = "bump" {}
    _Magnitude("Magnitude", Range(0,1)) = 0.05
  }
  ```
  2. 在Pass通道中添加下面的这些变量    
  ``` c#
  sampler2D _MainTex;
  sampler2D _BumpMap;
  float _Magnitude;
  sampler2D _GrabTexture;
  fixed4 _Colour;
  ```
  3. dd
  4. dd
  5. dd
  6. dd
  7. dd


