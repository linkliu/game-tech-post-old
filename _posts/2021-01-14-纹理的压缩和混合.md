---
category: shader
tags: [U3D, Shader,Cookbook,中文版]
---

## 纹理的压缩和混合

纹理的作用并不仅仅只是我们通常认为的保存加载的数据或者像素颜色，同时还有像素点在**x**和**y**方向以及RGBA通道的各种设置。我们能把多张图片压缩进一张单独的RGBA纹理中并且使用它们各自的R，G，B和A元素，因为我们可以在着色器中把它们各自纹理中的这些元素分别解压出来。

将各自的灰度图压缩进一张单独的RGBA纹理的结果可以通过下图看出来：

<div align="center"><img src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram23.png"/></div>



为什么说这会有用呢？在你的应用程序实际消耗的大部分中内存当中，贴图占了很大的一部分。所以如果你想要减少应用程序的大小的话，我们能在着色器中查看所有使用的图片并且想想我们是否能将这些纹理合并到一张单独的纹理中。

任何灰度的纹理都可以压缩进另一张有RGBA通道的纹理。第一次听起来可能有点怪怪的，但我们接下来会用这个知识点来演示纹理压缩的用法并且在我们的着色器中使用这张压缩过的纹理。

举其中一个纹理压缩用法例子，比如你想把一套纹理[有好几张]混合进一张单独的纹理中。这在地形类着色器中很常见，在我们的例子中，我们会用一些排好序的控制纹理或者压缩过的纹理，很好的混合进另一张纹理中。这个知识点会讲到这个技术的，同时还会告诉你如何开始编写好这样一个混合四张纹理的着色器。

***




- **始前准备**

  在我们Unity的着色器文件夹中创建一个新的着色器同时创建一个新的材质与之对应。这两者的命名怎么方便怎么来，不过尽量保证组织和引用方便吧。

  建好着色器和材质后，再创建一个新的场景，好给后面做测试。

  收集好四张你打算混合在一起的纹理。我们直接用它们展示这几张纹理是如何放到物体表面的。

  我们可以用一些非常复杂的混合纹理在地形网格上创建一个非常真实的地形分布纹理，如下所示：
  
  <div align="center"><img src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram24.png"/></div>

***




- **操作步骤**

  我们通过下面代码来学习如何使用压缩纹理。

  1. 我们在着色器的**属性Properties**块中添加一些属性。我们需要5个**sampler2D**类型的游戏对象或纹理，2个颜色属性：

     ```
     Properties
     {_
        MainTint ("Diffuse Tint", Color) = (1,1,1,1)
        //Add the properties below so we can input all of our textures
        _ColorA ("Terrain Color A", Color) = (1,1,1,1)
        _ColorB ("Terrain Color B", Color) = (1,1,1,1)
        _RTexture ("Red Channel Texture", 2D) = ""{}
        _GTexture ("Green Channel Texture", 2D) = ""{}
        _BTexture ("Blue Channel Texture", 2D) = ""{}
        _ATexture ("Alpha Channel Texture", 2D) = ""{}
        _BlendTex ("Blend Texture", 2D) = ""{}
     }
     ```

  2. 接下来我们在**SubShader{}**块中创建一些变量，记住要跟上一步的属性块对应。

     ```
   CGPROGRAM
     #pragma surface surf Lambert
   float4 _MainTint;
     float4 _ColorA;
   float4 _ColorB;
     sampler2D _RTexture;
     sampler2D _GTexture;
     sampler2D _BTexture;
     sampler2D _BlendTex;
     sampler2D _ATexture;
     ```
  
  3. 我们现在获得了纹理属性后把它们传递给**SubShader{}**函数。为了能够让使用者可以控制每个纹理的格子比例，我们需要修改**输入结构体Input struct**。这样我们就可以使用每个纹理的格子和偏移量等参数。
  
  4. d
  
  5. e
  
  6. f

